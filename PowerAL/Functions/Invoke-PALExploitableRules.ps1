function Invoke-PALExploitableRules
{
<#
.SYNOPSIS

Gets AppLocker rules that potentially can be exploited.

Author: @oddvarmoe
License: BSD 3-Clause
Required Dependencies: Get-PALRules, Get-PALRulesStatus, Get-PALWriteableAllowedPaths
Optional Dependencies: None

.DESCRIPTION

Checking AppLocker rules and looks for known weaknesses in configuration that can be exploited.

.EXAMPLE

PS C:\> Get-PALExploitableRules

Get-PALExploitableRules

[*] Checking for Exploitable AppLocker rules

[*] Checking Publisher rules
[+] Trust all signed rule found in Appx
[+] Get yourself a code signing cert and start a party!


Ruletype      : FilePublisherRule
Action        : Allow
SID           : S-1-1-0
Description   : Allows members of the Everyone group to run packaged apps that are signed.
Name          : (Default Rule) All signed packaged apps
Id            : a9e18c21-ff8f-43cf-b9fc-db40eed693ba
PublisherName : *
Productname   : *
BinaryName    : *
LowSection    : 0.0.0.0
HighSection   : *

[+] Trust all signed rule found in Msi
[+] Get yourself a code signing cert and start a party!
Ruletype      : FilePublisherRule
Action        : Allow
SID           : S-1-1-0
Description   : Allows members of the Everyone group to run digitally signed Windows Installer files.
Name          : (Default Rule) All digitally signed Windows Installer files
Id            : b7af7102-efde-4369-8a89-7a6a392d1473
PublisherName : *
Productname   : *
BinaryName    : *
LowSection    : 0.0.0.0
HighSection   : *


[*] Checking for missing or incorrect path rules
[+] Did not find any deny rules
[+] Did not find any rules blocking executing from Alternate Data Streams
[+] Exploit by adding a binary to a stream of a folder inside an allowed path. EX: type file.exe > c:\windows\tasks:file.exe

[*] Checking for denied AppLocker hash rules
[+] Did not find any hash deny rules
#>
# Function Version: 0.91    
    [CmdletBinding()] Param (
        [String]$OfflineXML
    )
    Process
    {
        Try
        {
            If($OfflineXML)
            {
                "`n[*] Checking for Exploitable AppLocker rules from Offline XML"
                $PublisherRules = Get-PALRulesNative -OutputRules Publisher -RuleActions Allow -OfflineXML $OfflineXML
                $DenyPathRules = Get-PALRulesNative -OutputRules Path -RuleActions Deny -OfflineXML $OfflineXML
                $DenyHashRules = Get-PALRulesNative -OutputRules Hash -RuleActions Deny -OfflineXML $OfflineXML
                $AllowPathRules = Get-PALRulesNative -OutputRules Path -RuleActions Allow -OfflineXML $OfflineXML
            }
            else
            {
                "`n[*] Checking for Exploitable AppLocker rules"
                $PublisherRules = Get-PALRules -OutputRules Publisher -RuleActions Allow
                $DenyPathRules = Get-PALRules -OutputRules Path -RuleActions Deny
                $DenyHashRules = Get-PALRules -OutputRules Hash -RuleActions Deny
                $AllowPathRules = Get-PALRules -OutputRules Path -RuleActions Allow
            }


            #######################
            #GENERAL CONFIGURATION#
            ####################### 

            #Check if some of the rule collections is not configured
            "`n[*] Checking rule collection status to see if one collection is not enabled"
            $RulesStatus = Get-PALRuleSectionStatus
            foreach($Ruless in $RulesStatus)
            {
                if($Ruless.status -ne "Enforced")
                {
                    "[+] $($Ruless.Name) is not enforced. Have fun!"
                }
            }

             #Check for allow rules on root folder

            #Check if Powershell v2 is allowed or not!
            "`n[*] Checking if PowerShell version 2 is enabled"
            $Posh2Enabled = Get-PALPoshV2Installed
            if($Posh2Enabled -eq "True")
            {
                "[+] Found that Powershell version 2 is enabled"
                "[+] Start Powershell with command: powershell -version 2"
            }
            else
            {
                "[-] Found that Powershell version 2 is disabled"
            }
            
            #######################
            # PUBLISHER RULES     #
            ####################### 
            #Check if there exists a trust all signed binaries rule
            $ExploitablePublisherRules = @()
            "`n[*] Checking Publisher rules"
            if($PublisherRules)
            {
                ForEach($PubSection in $PublisherRules)
                {
                    Foreach($PubRule in $PubSection.RulesList)
                    {
                        if($PubRule.Publishername -eq "*")
                        {
                            write-verbose "[+] Trust all signed rule found in $($pubSection.name)"
                            write-verbose "[+] Get yourself a code signing cert and start a party!"
                            $ExploitablePublisherRules += $PubRule
                        }
                    }
                }

                if($ExploitablePublisherRules)
                {
                    "[+] Found * Publisher Rules that can potentially be exploited:"
                    $ExploitablePublisherRules | Select-Object ParentName,PublisherName,ProductName,BinaryName | format-table
                }
            }

            
            #######################
            # PATH RULES          #
            #######################
            # NEED A FUNCTION THAT FIGURES OUT WRITABLE LOCATIONS THAT DOES NOT HAVE A DENY RULE APPLIED IN TERMS OF ADS
            
            #Check if there is an incorrect path rule
            "`n[*] Checking for missing or incorrect path rules"
            if($DenyPathRules)
            {
                $ExploitableDenyPathRules = @()
                
                ## ADS
                if(!($DenyPathRules.RulesList.RulePath -match "\:\*$"))
                {
                    "[+] Did not find any rules blocking execution from Alternate Data Streams"
                }

                ## Misconfigured Deny rules
                ForEach($DPR in $DenyPathRules.RulesList)
                {
                    if(!($($DPR.RulePath) -match "\\\*$" -or $($DPR.RulePath) -match "\.\w{2,4}$" -or $($DPR.RulePath) -match ":\*"))
                    {
                        write-verbose "[+] Found misconfigured deny path rule - Missing asterix (*) - Rule has no effect"
                        $ExploitableDenyPathRules += $DPR
                    }
                }

                if($ExploitableDenyPathRules)
                {
                    "[+] Misconfigured deny rules - Missing asterix (*) - Rule has no effect:"
                    $ExploitableDenyPathRules | Select-Object ParentName,RulePath | Format-Table
                }
            }
            else{
                "[+] Did not find any deny rules"
                "[+] Did not find any rules blocking execution from Alternate Data Streams"
                "[+] Exploit by adding a binary to a stream of a folder inside an allowed path. EX: type file.exe > c:\windows\tasks:file.exe"
            }

            #Find rules that allow path for a single filename
            # *file.exe and *file.exe*
            "`n[*] Checking if there are exploitable allowed path rules"

            $ExploitableAllowedPathRules = @()
            foreach($section in $AllowPathRules)
            {
                foreach($sect in $section.RulesList)
                {
                    if($sect.path -match "^\*\w+\.\w{2,4}\*$" -or $sect.path -match "^\*\w+\.\w{2,4}$")
                    {
                        write-verbose "[+] Found exploitable allowed path rule in section: $($sect.ParentName)"
                        $ExploitableAllowedPathRules += $sect
                    }
                }

                
            }

            if($ExploitableAllowedPathRules)
            {
                "[+] Allowed Rule paths that can potentially be exploited:"
                $ExploitableAllowedPathRules | Select-Object ParentName,RulePath | Format-Table
            }


            if(!($OfflineXML))
            {
                #Check for potential CLM bypass
                "`n[*] Checking for potential CLM bypass"
                #A bug... Needs to run it once before I can use rulesection and get the correct count
                #must be something related to global variables
                Get-PALWriteableAllowedPaths | Out-Null
                $CLMInjectiblePaths = Get-PALWriteableAllowedPaths -RuleSection Script
                If($($CLMInjectiblePaths.count) -eq "0")
                {
                    
                    "[-] No user writeable allowed paths found for CLM bypass"
                }
                else
                {
                    "[+] Found $($CLMInjectiblePaths.count) potential paths that can be used for CLM bypass"
                    "[+] Use Invoke-PALCLMTempBypass to attempt to launch a full language mode PowerShell session"
                }
            }


            #######################
            # HASH RULES          #
            #######################
            #Check if there are rules that denies a file hash
            "`n[*] Checking for denied AppLocker hash rules"
            if($DenyHashRules)
            {
                ForEach($HR in $DenyHashRules)
                {
                    "[+] Found hash deny rule" 
                    "[+] - Add content to file and execute: copy /b blockedfile.exe+txtfile.txt newfile.txt"
                    $HR.RulesList | fl *
                }
            }
            else
            {
                write-verbose "[-] Did not find any hash deny rules"
            }

        }
        Catch
        {
            write-error $_
        }
        Finally{}
    }
}